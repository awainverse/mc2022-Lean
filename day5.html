
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>5. Bits &amp; Pieces &#8212; Lean at MC 2022 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Pretty Symbols in Lean" href="symbols.html" />
    <link rel="prev" title="4. Sqrt 2 is irrational" href="day4.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="bits-pieces">
<span id="day5"></span><h1><span class="section-number">5. </span>Bits &amp; Pieces<a class="headerlink" href="#bits-pieces" title="Permalink to this heading">&#182;</a></h1>
<section id="namespaces">
<h2><span class="section-number">5.1. </span>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this heading">&#182;</a></h2>
<p>Lean provides us with the ability to group definitions into nested, hierarchical <em>namespaces</em>:</p>
<div id="namespace-example" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=namespace%20mcsp%0A%20%20def%20tau%20%3A%3D%20%22TAU%20on%20T-F%20from%202-4%22%0A%20%20%23eval%20tau%0Aend%20mcsp%0A%0Adef%20tau%20%3A%3D%20%22no%20TAU%20on%20S%22%0A%23eval%20tau%0A%23eval%20mcsp.tau%0A%0Aopen%20mcsp%0A%0A%23eval%20tau%20--%20error%0A%23eval%20mcsp.tau" id="namespace-example" target="_blank" tryitfile="../examples/day5/namespace_example.lean">
try it!</a></div><div class="highlight-lean notranslate" id="namespace-example"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="n">mcsp</span>
  <span class="kd">def</span> <span class="n">tau</span> <span class="o">:=</span> <span class="s2">&quot;TAU on T-F from 2-4&quot;</span>
  <span class="k">#eval</span> <span class="n">tau</span>
<span class="kd">end</span> <span class="n">mcsp</span>

<span class="kd">def</span> <span class="n">tau</span> <span class="o">:=</span> <span class="s2">&quot;no TAU on S&quot;</span>
<span class="k">#eval</span> <span class="n">tau</span>
<span class="k">#eval</span> <span class="n">mcsp.tau</span>

<span class="kn">open</span> <span class="n">mcsp</span>

<span class="k">#eval</span> <span class="n">tau</span> <span class="c1">-- error</span>
<span class="k">#eval</span> <span class="n">mcsp.tau</span>
</pre></div>
</div>
</div><p>When we declare that we are working in the namespace <code class="docutils literal notranslate"><span class="pre">mcsp</span></code>, every identifier we declare has a full name with prefix &#8220;<code class="docutils literal notranslate"><span class="pre">mcsp</span></code>&#8221;.
Within the namespace, we can refer to identifiers by their shorter names, but once we end the namespace, we have to use the longer names.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">open</span></code> command brings the shorter names into the current context. Often, when we import a theory file, we will want to open one or more of the namespaces it contains, to have access to the short identifiers.
Further if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">nat</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code> is a term defined in namespace <code class="docutils literal notranslate"><span class="pre">nat</span></code> then <code class="docutils literal notranslate"><span class="pre">nat.f</span> <span class="pre">x</span></code> can be shortened to <code class="docutils literal notranslate"><span class="pre">x.f</span></code>.
Note that <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> is just another notation for <code class="docutils literal notranslate"><span class="pre">nat</span></code>.</p>
</section>
<section id="coercions">
<h2><span class="section-number">5.2. </span>Coercions<a class="headerlink" href="#coercions" title="Permalink to this heading">&#182;</a></h2>
<p>In type theory every term has a type and two terms of different types cannot be equal to each other.
This makes it impossible to write statements like <code class="docutils literal notranslate"><span class="pre">|m|^2</span> <span class="pre">=</span> <span class="pre">m^2</span></code> where <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">:</span> <span class="pre">&#8484;</span></code> and <code class="docutils literal notranslate"><span class="pre">|m|</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code> is the absolute value of <code class="docutils literal notranslate"><span class="pre">m</span></code>.
But in math, we do want this statement to be true!
The round about way to deal with this is through <em>coercions</em>.
Lean will coerce the above equality to live entirely in integers as, <code class="docutils literal notranslate"><span class="pre">&#8593;|m|^2</span> <span class="pre">=</span> <span class="pre">m^2</span></code>.
This is done using an injective function <code class="docutils literal notranslate"><span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8484;</span></code>.</p>
<p>Sometimes it is possible (and necessary) to get rid of the coercions.
For example, say we start out with <code class="docutils literal notranslate"><span class="pre">&#8593;|m|^2</span> <span class="pre">=</span> <span class="pre">m^2</span></code> and eventually reduce it to <code class="docutils literal notranslate"><span class="pre">&#8593;|m|^2</span> <span class="pre">=</span> <span class="pre">&#8593;1</span></code>.
The tactic for getting rid of coercions is <code class="docutils literal notranslate"><span class="pre">norm_cast</span></code> which will reduce the above expression to <code class="docutils literal notranslate"><span class="pre">|m|^2</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">norm_cast</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">norm_cast,</span></code> tries to clear out coercions.</p>
<p><code class="docutils literal notranslate"><span class="pre">norm_cast</span> <span class="pre">at</span> <span class="pre">hp,</span></code> tries to clear out coercions at the hypothesis <code class="docutils literal notranslate"><span class="pre">hp</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div id="id1" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%20data.nat.basic%20data.int.basic%0Anoncomputable%20theory%0Aopen_locale%20classical%0A%0Atheorem%20sqrt2_irrational_nat%20%3A%0A%20%20%C2%AC%20%E2%88%83%20(m%20n%20%3A%20%E2%84%95)%2C%0A%20%202%20*%20m%5E2%20%3D%20n%5E2%20%E2%88%A7%0A%20%20m%20%E2%89%A0%200%0A%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A--%20Assume%20the%20above%20theorem%0A%0Alemma%20num_2%20%3A%20(2%20%3A%20%E2%84%9A).num%20%3D%202%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Alemma%20denom_2%20%3A%20(2%20%3A%20%E2%84%9A).denom%20%3D%201%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A%2F-%0Aq.denom%20%3D%20denominator%20of%20q%20(valued%20in%20%E2%84%95)%0Aq.num%20%3D%20numerator%20of%20q%20(valued%20in%20%E2%84%A4)%0A%0Afor%20integer%20m%2C%0Am.nat_abs%20%3D%20absolute%20value%20of%20m%20(valued%20in%20%E2%84%95)%0A%0Aint.nat_abs_mul_self'%20%3A%20%E2%88%80%20(a%20%3A%20%E2%84%A4)%2C%20%E2%86%91(a.nat_abs)%20*%20%E2%86%91(a.nat_abs)%20%3D%20a%20*%20a%0Aint.coe_nat_inj%20%3A%20%E2%88%80%20%7Bm%20n%20%3A%20%E2%84%95%7D%2C%20%E2%86%91m%20%3D%20%E2%86%91n%20%E2%86%92%20m%20%3D%20n%0A%0Arat.mul_self_denom%20%3A%20%E2%88%80%20(q%20%3A%20%E2%84%9A)%2C%20(q%20*%20q).denom%20%3D%20q.denom%20*%20q.denom%0Arat.mul_self_num%20%3A%20%E2%88%80%20(q%20%3A%20%E2%84%9A)%2C%20(q%20*%20q).num%20%3D%20q.num%20*%20q.num%0Arat.denom_ne_zero%20%3A%20%E2%88%80%20(q%20%3A%20%E2%84%9A)%2C%20q.denom%20%E2%89%A0%200%0A%0Alemmas%20about%20nat-to-int%20coercion%2C%20which%20norm_cast%20knows%3A%0Anat.cast_one%20%3A%20%E2%86%91(1%20%3A%20%E2%84%95)%20%3D%20(1%20%3A%20%E2%84%A4)%0Anat.cast_two%20%3A%20%E2%86%91(2%20%3A%20%E2%84%95)%20%3D%20(2%20%3A%20%E2%84%A4)%0Anat.cast_mul%20(m%20n%20%3A%20%E2%84%95)%20%3A%20%E2%86%91(m%20*%20n)%20%3D%20%E2%86%91m%20*%20%E2%86%91n%0A%0Alemma%20which%20ring_nf%20knows%3A%0Apow_two%20(x)%20%3A%20x%5E2%20%3D%20x%20*%20x%0A%0A-%2F%0A%0Atheorem%20sqrt2_irrational%20%3A%0A%C2%AC%20(%E2%88%83%20q%20%3A%20%E2%84%9A%2C%202%20%3D%20q%20*%20q)%0A%3A%3D%0Abegin%0A%20%20rintro%20%E2%9F%A8q%2C%20h%E2%9F%A9%2C%0A%20%20have%20clear_denom%20%3A%3D%20rat.eq_iff_mul_eq_mul.mp%20h%2C%0A%20%20sorry%2C%0Aend" id="id1" target="_blank" tryitfile="../examples/day5/coercions.lean">
try it!</a></div><div class="highlight-lean notranslate" id="id1"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span> <span class="n">data.nat.basic</span> <span class="n">data.int.basic</span>
<span class="kd">noncomputable theory</span>
<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">theorem</span> <span class="n">sqrt2_irrational_nat</span> <span class="o">:</span>
  <span class="bp">&#172;</span> <span class="bp">&#8707;</span> <span class="o">(</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span>
  <span class="mi">2</span> <span class="bp">*</span> <span class="n">m</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">n</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">&#8743;</span>
  <span class="n">m</span> <span class="bp">&#8800;</span> <span class="mi">0</span>
<span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Assume the above theorem</span>

<span class="kd">lemma</span> <span class="n">num_2</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">&#8474;</span><span class="o">)</span><span class="bp">.</span><span class="n">num</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">denom_2</span> <span class="o">:</span> <span class="o">(</span><span class="mi">2</span> <span class="o">:</span> <span class="n">&#8474;</span><span class="o">)</span><span class="bp">.</span><span class="n">denom</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">q.denom = denominator of q (valued in &#8469;)</span>
<span class="cm">q.num = numerator of q (valued in &#8484;)</span>

<span class="cm">for integer m,</span>
<span class="cm">m.nat_abs = absolute value of m (valued in &#8469;)</span>

<span class="cm">int.nat_abs_mul_self&#39; : &#8704; (a : &#8484;), &#8593;(a.nat_abs) * &#8593;(a.nat_abs) = a * a</span>
<span class="cm">int.coe_nat_inj : &#8704; {m n : &#8469;}, &#8593;m = &#8593;n &#8594; m = n</span>

<span class="cm">rat.mul_self_denom : &#8704; (q : &#8474;), (q * q).denom = q.denom * q.denom</span>
<span class="cm">rat.mul_self_num : &#8704; (q : &#8474;), (q * q).num = q.num * q.num</span>
<span class="cm">rat.denom_ne_zero : &#8704; (q : &#8474;), q.denom &#8800; 0</span>

<span class="cm">lemmas about nat-to-int coercion, which norm_cast knows:</span>
<span class="cm">nat.cast_one : &#8593;(1 : &#8469;) = (1 : &#8484;)</span>
<span class="cm">nat.cast_two : &#8593;(2 : &#8469;) = (2 : &#8484;)</span>
<span class="cm">nat.cast_mul (m n : &#8469;) : &#8593;(m * n) = &#8593;m * &#8593;n</span>

<span class="cm">lemma which ring_nf knows:</span>
<span class="cm">pow_two (x) : x^2 = x * x</span>

<span class="cm">-/</span>

<span class="kd">theorem</span> <span class="n">sqrt2_irrational</span> <span class="o">:</span>
<span class="bp">&#172;</span> <span class="o">(</span><span class="bp">&#8707;</span> <span class="n">q</span> <span class="o">:</span> <span class="n">&#8474;</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">=</span> <span class="n">q</span> <span class="bp">*</span> <span class="n">q</span><span class="o">)</span>
<span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintro</span> <span class="o">&#10216;</span><span class="n">q</span><span class="o">,</span> <span class="n">h</span><span class="o">&#10217;,</span>
  <span class="k">have</span> <span class="n">clear_denom</span> <span class="o">:=</span> <span class="n">rat.eq_iff_mul_eq_mul.mp</span> <span class="n">h</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="type-classes">
<h2><span class="section-number">5.3. </span>Type classes<a class="headerlink" href="#type-classes" title="Permalink to this heading">&#182;</a></h2>
<p>Type classes are used to construct complex mathematical structures.
Any family of types can be marked as a type class.
We can then declare particular elements of a type class to be instances.
You can think of a type class as &#8220;template&#8221; for constructing particular instances.</p>
<p>Consider the example of groups.
A group is defined a type class with the following attributes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>structure group : Type u &#8594; Type u
fields:
group.mul : &#928; {&#945; : Type u} [c : group &#945;], &#945; &#8594; &#945; &#8594; &#945;
group.mul_assoc : &#8704; {&#945; : Type u} [c : group &#945;] (a b c_1 : &#945;), a * b * c_1 = a * (b * c_1)
group.one : &#928; {&#945; : Type u} [c : group &#945;], &#945;
group.one_mul : &#8704; {&#945; : Type u} [c : group &#945;] (a : &#945;), 1 * a = a
group.mul_one : &#8704; {&#945; : Type u} [c : group &#945;] (a : &#945;), a * 1 = a
group.inv : &#928; {&#945; : Type u} [c : group &#945;], &#945; &#8594; &#945;
group.mul_left_inv : &#8704; {&#945; : Type u} [c : group &#945;] (a : &#945;), a&#8315;&#185; * a = 1
</pre></div>
</div>
<p>If you look at the <a class="reference external" href="https://github.com/leanprover-community/mathlib/blob/e52108d/src/algebra/group/defs.lean">source code</a> you&#8217;ll see that the <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">group</span></code> is built gradually by extending multiple classes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class has_one      (&#945; : Type u) := (one : &#945;)
-- a group has an identity element

class has_mul      (&#945; : Type u) := (mul : &#945; &#8594; &#945; &#8594; &#945;)
-- a group has multiplication

class has_inv      (&#945; : Type u) := (inv : &#945; &#8594; &#945;)
-- a group has an inverse function

class semigroup (G : Type u) extends has_mul G :=
(mul_assoc : &#8704; a b c : G, a * b * c = a * (b * c))
-- the multiplication is associative

class monoid (M : Type u) extends semigroup M, has_one M :=
(one_mul : &#8704; a : M, 1 * a = a) (mul_one : &#8704; a : M, a * 1 = a)
-- multiplication by one is trivial

class group (&#945; : Type u) extends monoid &#945;, has_inv &#945; :=
(mul_left_inv : &#8704; a : &#945;, a&#8315;&#185; * a = 1)
-- multiplication is associative
</pre></div>
</div>
<p>To define an arbitrary group <code class="docutils literal notranslate"><span class="pre">G</span></code> we first create it as a type <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">:</span> <span class="pre">Type</span></code> and then make it an instance of <code class="docutils literal notranslate"><span class="pre">group</span></code> using
<code class="docutils literal notranslate"><span class="pre">[group</span> <span class="pre">G]</span></code>.
You can also prove that existing types are instances of <code class="docutils literal notranslate"><span class="pre">group</span></code> using the <code class="docutils literal notranslate"><span class="pre">instance</span></code> keyword.
Type classes allow us to prove theorems in vast generalities.
For example, any theorem about groups can immediately be applied to integers once we show that integers are an instance of <code class="docutils literal notranslate"><span class="pre">group</span></code>.
If you look at <a class="reference external" href="https://github.com/leanprover-community/mathlib/blob/d1e63f3/src/data/int/basic.lean">data.int.basic</a>
you&#8217;ll see that first fifty lines of code prove that <code class="docutils literal notranslate"><span class="pre">&#8484;</span></code> is an instance of several type classes.</p>
<div id="cyclic-group" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20group_theory.order_of_element%0Aimport%20tactic%0A%0A%23print%20classes%0A%23print%20instances%20inhabited%0A%0Aclass%20cyclic_group%20(G%20%3A%20Type*)%20extends%20group%20G%20%3A%3D%0A(has_generator%3A%20%20%E2%88%83%20g%20%3A%20G%2C%20%E2%88%80%20x%20%3A%20G%2C%20%E2%88%83%20n%20%3A%20%E2%84%A4%2C%20x%20%3D%20g%5En)%0A%0A%2F-%0Azpow_add%20%3A%20%E2%88%80%20%7BG%20%3A%20Type%20u_1%7D%20%5Bgroup%20G%5D%20(a%20%3A%20G)%20(m%20n%20%3A%20%E2%84%A4)%2C%20a%20%5E%20(m%20%2B%20n)%20%3D%20a%20%5E%20m%20*%20a%20%5E%20n%0Aadd_comm%20%3A%20%E2%88%80%20%7BG%20%3A%20Type%20u_1%7D%20%5Badd_comm_semigroup%20G%5D%20(a%20b%20%3A%20G)%2C%20a%20%2B%20b%20%3D%20b%20%2B%20a%0A-%2F%0A%0Alemma%20mul_comm_of_cyclic%0A%20%20%7BG%20%3A%20Type*%7D%0A%20%20%5Bhc%3A%20cyclic_group%20G%5D%0A%20%20(g%20%3A%20G)%0A%3A%20%E2%88%80%20a%20b%20%3A%20G%2C%20a%20*%20b%20%3D%20b%20*%20a%20%3A%3D%0Abegin%0A%20%20have%20has_generator%20%3A%3D%20hc.has_generator%2C%0A%20%20sorry%2C%0Aend" id="cyclic-group" target="_blank" tryitfile="../examples/day5/cyclic_group.lean">
try it!</a></div><div class="highlight-lean notranslate" id="cyclic-group"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">group_theory.order_of_element</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="k">#print</span> <span class="n">classes</span>
<span class="k">#print</span> <span class="n">instances</span> <span class="n">inhabited</span>

<span class="kd">class</span> <span class="n">cyclic_group</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">group</span> <span class="n">G</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">has_generator</span><span class="o">:</span>  <span class="bp">&#8707;</span> <span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">g</span><span class="bp">^</span><span class="n">n</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">zpow_add : &#8704; {G : Type u_1} [group G] (a : G) (m n : &#8484;), a ^ (m + n) = a ^ m * a ^ n</span>
<span class="cm">add_comm : &#8704; {G : Type u_1} [add_comm_semigroup G] (a b : G), a + b = b + a</span>
<span class="cm">-/</span>

<span class="kd">lemma</span> <span class="n">mul_comm_of_cyclic</span>
  <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">[</span><span class="n">hc</span><span class="o">:</span> <span class="n">cyclic_group</span> <span class="n">G</span><span class="o">]</span>
  <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">G</span><span class="o">)</span>
<span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">G</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">has_generator</span> <span class="o">:=</span> <span class="n">hc.has_generator</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="recursion-and-induction">
<h2><span class="section-number">5.4. </span>Recursion and Induction<a class="headerlink" href="#recursion-and-induction" title="Permalink to this heading">&#182;</a></h2>
<p>Lots of things in Lean are defined using recursion and proved using induction.
While this extends beyond just the natural numbers,
let&#8217;s try some familiar examples using the natural numbers and the familiar principle of induction.</p>
<p>First let&#8217;s see how to make a recursive definition. I&#8217;ll define afunction called <code class="docutils literal notranslate"><span class="pre">sum_first</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8469;</span></code>
so that <code class="docutils literal notranslate"><span class="pre">sum_first</span> <span class="pre">n</span></code> is the sum of the first <code class="docutils literal notranslate"><span class="pre">n</span></code> natural numbers.</p>
<div id="sum-first-defn" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0Aimport%20tactic%0A%0Adef%20sum_first%20%3A%0A%20%20%E2%84%95%20%E2%86%92%20%E2%84%95%20--%20the%20type%20of%20the%20function%20you%20want%20to%20define%20recursively%0A%7C%200%20%3A%3D%200%20--%20the%20definition%20at%200%0A%7C%20(n%20%2B%201)%20%3A%3D%20sum_first%20n%20%2B%20(n%20%2B%201)%20--%20the%20definition%20at%20(n%20%2B%201)%2C%20which%20can%20use%20the%20definition%20at%20n" id="sum-first-defn" target="_blank" tryitfile="../examples/day5/sum_first_defn.lean">
try it!</a></div><div class="highlight-lean notranslate" id="sum-first-defn"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">def</span> <span class="n">sum_first</span> <span class="o">:</span>
  <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span> <span class="c1">-- the type of the function you want to define recursively</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">-- the definition at 0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sum_first</span> <span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- the definition at (n + 1), which can use the definition at n</span>
</pre></div>
</div>
</div><p>Now let&#8217;s prove the famous closed formula for <code class="docutils literal notranslate"><span class="pre">sum_first</span> <span class="pre">n</span></code>, using induction.
To do this, we&#8217;ll want the following two tactics:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">induction</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code> is a natural number variable, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">Prop</span></code> is a property of natural numbers,
and you want to prove <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> using induction, then <code class="docutils literal notranslate"><span class="pre">induction</span> <span class="pre">n</span> <span class="pre">using</span> <span class="pre">k</span> <span class="pre">ih,</span></code> will create two goals.</p>
<p>One has target <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">0</span></code>, this is the base case.</p>
<p>The other has target <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">(k.succ)</span></code>, where <code class="docutils literal notranslate"><span class="pre">k.succ</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">+</span> <span class="pre">1</span></code>.
(You can rewrite away the <code class="docutils literal notranslate"><span class="pre">.succ</span></code> with <code class="docutils literal notranslate"><span class="pre">nat.succ_eq_add_one</span></code>.)
You&#8217;re also provided an induction hypothesis, <code class="docutils literal notranslate"><span class="pre">ih</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">k</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">refl</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">refl,</span></code> proves things that are literally true by definition.
Often this will handle your base case.</p></td>
</tr>
</tbody>
</table>
<p>Now let&#8217;s try the proof. Remember that <code class="docutils literal notranslate"><span class="pre">rw</span></code> can be useful for unfolding definitions.</p>
<div id="sum-first-formula" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.basic%0Aimport%20tactic%0A%0A%2F--------------------------------------------------------------------------%0A%0A%60%60induction%60%60%0A%0A%20%20If%20%60%60n%20%3A%20%E2%84%95%60%60%20is%20a%20natural%20number%20variable%2C%20%60%60P%20%3A%20%E2%84%95%20%E2%86%92%20Prop%60%60%20is%20a%20property%20of%20natural%20numbers%2C%0A%20%20and%20you%20want%20to%20prove%20%60%60P%20n%60%60%20using%20induction%2C%20then%20%60%60induction%20n%20using%20k%20ih%2C%60%60%20will%20create%20two%20goals.%0A%20%20One%20is%20the%20base%20case%2C%20the%20other%20is%20the%20induction%20step.%0A%0A%0A%60%60rintro%60%60%0A%0A%20%20If%20the%20target%20of%20the%20current%20goal%20is%20a%20function%20%60%60P%20%E2%86%92%20Q%60%60%2C%20then%0A%20%20%60%60rintro%20hp%2C%60%60%20will%20produce%20a%20hypothesis%0A%20%20%60%60hp%20%3A%20P%60%60%20and%20change%20the%20target%20to%20%20%60%60Q%60%60.%0A%0Anat.succ_eq_add_one%20%3A%20%E2%88%80%20(n%20%3A%20%E2%84%95)%2C%20n.succ%20%3D%20n%20%2B%201%0A%0A--------------------------------------------------------------------------%2F%0A%0Adef%20sum_first%20%3A%0A%20%20%E2%84%95%20%E2%86%92%20%E2%84%95%20--%20the%20type%20of%20the%20function%20you%20want%20to%20define%20recursively%0A%7C%200%20%3A%3D%200%20--%20the%20definition%20at%200%0A%7C%20(n%20%2B%201)%20%3A%3D%20sum_first%20n%20%2B%20(n%20%2B%201)%20--%20the%20definition%20at%20(n%20%2B%201)%2C%20which%20can%20use%20the%20definition%20at%20n%0A%0Atheorem%20sum_first_formula%20%3A%20%E2%88%80%20(n%20%3A%20%E2%84%95)%2C%202%20*%20sum_first%20n%20%3D%20(n%20%2B%201)%20*%20n%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend" id="sum-first-formula" target="_blank" tryitfile="../examples/day5/sum_first_formula.lean">
try it!</a></div><div class="highlight-lean notranslate" id="sum-first-formula"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">data.nat.basic</span>
<span class="kn">import</span> <span class="n">tactic</span>

<span class="sd">/--------------------------------------------------------------------------</span>

<span class="sd">``induction``</span>

<span class="sd">  If ``n : &#8469;`` is a natural number variable, ``P : &#8469; &#8594; Prop`` is a property of natural numbers,</span>
<span class="sd">  and you want to prove ``P n`` using induction, then ``induction n using k ih,`` will create two goals.</span>
<span class="sd">  One is the base case, the other is the induction step.</span>


<span class="sd">``rintro``</span>

<span class="sd">  If the target of the current goal is a function ``P &#8594; Q``, then</span>
<span class="sd">  ``rintro hp,`` will produce a hypothesis</span>
<span class="sd">  ``hp : P`` and change the target to  ``Q``.</span>

<span class="sd">nat.succ_eq_add_one : &#8704; (n : &#8469;), n.succ = n + 1</span>

<span class="sd">--------------------------------------------------------------------------/</span>

<span class="kd">def</span> <span class="n">sum_first</span> <span class="o">:</span>
  <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span> <span class="c1">-- the type of the function you want to define recursively</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">-- the definition at 0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sum_first</span> <span class="n">n</span> <span class="bp">+</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">-- the definition at (n + 1), which can use the definition at n</span>

<span class="kd">theorem</span> <span class="n">sum_first_formula</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">sum_first</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If you want more practice proving things about natural numbers, including plenty of induction, try the <a class="reference external" href="https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/">Natural Number Game</a>.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Lean at MC 2022</a></h1>








<!-- <h3>Navigation</h3> -->
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="day1.html">1. Logic in Lean - Part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="day2.html">2. Logic in Lean - Part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="day3.html">3. Infinitely Many Primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="day4.html">4. Sqrt 2 is irrational</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Bits &amp; Pieces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#namespaces">5.1. Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coercions">5.2. Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-classes">5.3. Type classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursion-and-induction">5.4. Recursion and Induction</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="symbols.html">Pretty Symbols in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Glossary of Tactics and Lemmas</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://awainverse.github.io/mc2022-Lean/latex/lean_at_mc2022.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/lean-web-editor/">Lean Live Editor</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/mathlib_docs/">Lean Documentation</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/">Leanprover Community</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Aaron Anderson, Apurva Nakade, Jalex Stark.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/day5.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>