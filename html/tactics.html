
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Glossary of Tactics and Lemmas &#8212; Lean at MC 2022 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Pretty Symbols in Lean" href="symbols.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="glossary-of-tactics-and-lemmas">
<span id="tactics"></span><h1>Glossary of Tactics and Lemmas<a class="headerlink" href="#glossary-of-tactics-and-lemmas" title="Permalink to this heading">&#182;</a></h1>
<p>Here&#8217;s a summary of all the tactics and some of the lemmas we will introduce in this class, as well as some other common ones you may encounter.</p>
<section id="implications-in-lean">
<h2>Implications in Lean<a class="headerlink" href="#implications-in-lean" title="Permalink to this heading">&#182;</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">refine</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> is the target of the current goal
and <code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span></code>,
then <code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">hp,</span></code> will close the goal.</p>
<p>Mathematically, this saying &#8220;this is what we were required to prove&#8221;.</p>
<p>If you can&#8217;t fully close a goal, but want to work somewhat from the end, you can use <code class="docutils literal notranslate"><span class="pre">_</span></code> to fill in the missing pieces.
For instance, if the target of the current goal is <code class="docutils literal notranslate"><span class="pre">Q</span></code> and
<code class="docutils literal notranslate"><span class="pre">f</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">f</span> <span class="pre">_,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
<p>If you can fully close a goal, you can also type <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">hp,</span></code>, which does pretty much the same thing.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rintro</span></code></p></td>
<td><p>If the target of the current goal is a function <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code>,
then <code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">hp,</span></code> will produce a hypothesis
<code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> and change the target to  <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p>Mathematically, this is saying that in order to define a function from <code class="docutils literal notranslate"><span class="pre">P</span></code> to <code class="docutils literal notranslate"><span class="pre">Q</span></code>,
we first need to choose (introduce) an arbitrary element of <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
<p>If you want to use this repeatedly, you can type <code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">h1</span> <span class="pre">h2</span></code> instead of <code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">h1,</span></code> and then <code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">h2,</span></code>.
If you want to use this to introduce a variable of a more complicated type that you would then apply <code class="docutils literal notranslate"><span class="pre">cases</span></code> to,
you can try something like <code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">&#10216;x1,</span> <span class="pre">x2,</span> <span class="pre">x3&#10217;,</span></code> where <code class="docutils literal notranslate"><span class="pre">&#10216;&#10217;</span></code> are typed with <code class="docutils literal notranslate"><span class="pre">\langle`</span> <span class="pre">and</span> <span class="pre">``\rangle</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">have</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">have</span></code> is used to create intermediate variables.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">f</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code> and
<code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span></code>, then
<code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">hq</span> <span class="pre">:=</span> <span class="pre">f(hp),</span></code> creates the hypothesis <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">Q</span></code> .</p>
<p>You can also create subgoals with <code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P,</span></code> which will create a separate goal to prove <code class="docutils literal notranslate"><span class="pre">P</span></code>.
Once you have closed this goal, you&#8217;ll have the hypothesis <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> at your disposal.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">set</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">set</span></code> is used to create intermediate variables or abbreviations.
It&#8217;s pretty similar to <code class="docutils literal notranslate"><span class="pre">have</span></code>, with one important difference.
If you type <code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">:=</span> <span class="pre">y,</span></code>, Lean remembers that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code>, but
does not remember that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code>.
Meanwhile, <code class="docutils literal notranslate"><span class="pre">set</span></code> remembers, so if you type <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">:=</span> <span class="pre">y</span> <span class="pre">with</span> <span class="pre">hx,</span></code> you also get <code class="docutils literal notranslate"><span class="pre">hx</span> <span class="pre">:</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code>,
which you can use to rewrite.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">apply</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">apply</span></code> is used for backward reasoning.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">Q</span></code> and
<code class="docutils literal notranslate"><span class="pre">f</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">f,</span></code> changes target to <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
<p>Mathematically, this is equivalent to saying &#8220;because <code class="docutils literal notranslate"><span class="pre">P</span></code> implies <code class="docutils literal notranslate"><span class="pre">Q</span></code>, to prove <code class="docutils literal notranslate"><span class="pre">Q</span></code> it suffices to prove <code class="docutils literal notranslate"><span class="pre">P</span></code>&#8221;.
This is similar to using <code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">_,</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="and-or">
<h2>And / Or<a class="headerlink" href="#and-or" title="Permalink to this heading">&#182;</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cases</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cases</span></code> is a general tactic that breaks a complicated term into simpler ones.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hpq</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8743;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hpq</span> <span class="pre">with</span> <span class="pre">hp</span> <span class="pre">hq,</span></code> breaks it into <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">Q</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hpq</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#215;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hpq</span> <span class="pre">with</span> <span class="pre">hp</span> <span class="pre">hq,</span></code> breaks it into <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">Q</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">fg</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8596;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">fg</span> <span class="pre">with</span> <span class="pre">f</span> <span class="pre">g,</span></code> breaks it into <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">:</span> <span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hpq</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hpq</span> <span class="pre">with</span> <span class="pre">hp</span> <span class="pre">hq,</span></code> creates two goals and adds the hypotheses <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">hq</span> <span class="pre">:</span> <span class="pre">Q</span></code> to one each.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">split</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">split</span></code> is a general tactic that breaks a complicated goal into simpler ones.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8743;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">split,</span></code> breaks up the goal into two goals with targets <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#215;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">split,</span></code> breaks up the goal into two goals with targets <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8596;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">split,</span></code> breaks up the goal into two goals with targets <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code>.</p>
<p>You can also accomplish this with <code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">&#10216;_,</span> <span class="pre">_&#10217;</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">left</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">left,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">right</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">Q</span></code>, then
<code class="docutils literal notranslate"><span class="pre">right,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rcases</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">rcases</span></code> is a more general form of <code class="docutils literal notranslate"><span class="pre">cases</span></code>. Needs the symbols <code class="docutils literal notranslate"><span class="pre">&#10216;&#10217;</span></code>, which are typed with <code class="docutils literal notranslate"><span class="pre">\langle</span></code> and <code class="docutils literal notranslate"><span class="pre">\rangle</span></code>.</p>
<p>For an example, say you have <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">&#8707;</span> <span class="pre">(m</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">&#8469;),</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">m</span> <span class="pre">^</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">^</span> <span class="pre">2</span> <span class="pre">&#8743;</span> <span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">m</span></code>.
Then you can type <code class="docutils literal notranslate"><span class="pre">rcases</span> <span class="pre">h</span> <span class="pre">with</span> <span class="pre">&#10216;m,</span> <span class="pre">n,</span> <span class="pre">hmn,</span> <span class="pre">hme0&#10217;,</span></code> to break <code class="docutils literal notranslate"><span class="pre">h</span></code> into its 4 component parts.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="negations-and-proof-by-contradiction">
<h2>Negations and Proof by Contradiction<a class="headerlink" href="#negations-and-proof-by-contradiction" title="Permalink to this heading">&#182;</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">false.elim</span></code></p></td>
<td><p>Not a tactic, but a lemma.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, then <code class="docutils literal notranslate"><span class="pre">false.elim</span> <span class="pre">:</span> <span class="pre">false</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code> lets you prove <code class="docutils literal notranslate"><span class="pre">P</span></code> from a contradiction.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">exfalso</span></code></p></td>
<td><p>Changes the target of the current goal to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>The name derives from <a class="reference external" href="https://en.wikipedia.org/wiki/Principle_of_explosion">&#8220;ex falso, quodlibet&#8221;</a> which translates to &#8220;from contradiction, anything&#8221;.
You should use this tactic when there are contradictory hypotheses present.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">em</span></code></p></td>
<td><p>Not a tactic, but a lemma.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, then <code class="docutils literal notranslate"><span class="pre">em</span> <span class="pre">P</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">&#172;</span> <span class="pre">P</span></code> lets you use the law of the excluded middle on <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">by_cases</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, then <code class="docutils literal notranslate"><span class="pre">by_cases</span> <span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P,</span></code> creates two goals,
the first with a hypothesis <code class="docutils literal notranslate"><span class="pre">hp:</span> <span class="pre">P</span></code> and second with a hypothesis <code class="docutils literal notranslate"><span class="pre">hp:</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>.</p>
<p>This lets you use the law of the excluded middle, combining <code class="docutils literal notranslate"><span class="pre">em</span></code> with <code class="docutils literal notranslate"><span class="pre">cases</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">by_contradiction</span></code></p></td>
<td><p>If the target of the current goal is  <code class="docutils literal notranslate"><span class="pre">Q</span></code>,
then <code class="docutils literal notranslate"><span class="pre">by_contradiction,</span></code> changes the target to  <code class="docutils literal notranslate"><span class="pre">false</span></code> and
adds <code class="docutils literal notranslate"><span class="pre">hnq</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">Q</span></code> as a hypothesis.</p>
<p>Mathematically, this is proof by contradiction.
This is essentially a combination of <code class="docutils literal notranslate"><span class="pre">rintro</span></code> with <code class="docutils literal notranslate"><span class="pre">false.elim</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">push_neg</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">push_neg,</span></code> simplifies negations in the target.</p>
<p>For example, if the target of the current goal is <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>, then
<code class="docutils literal notranslate"><span class="pre">push_neg,</span></code> simplifies it to <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
<p>You can also push negations across a hypothesis <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> using <code class="docutils literal notranslate"><span class="pre">push_neg</span> <span class="pre">at</span> <span class="pre">hp,</span></code>.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">contrapose!</span></code></p></td>
<td><p>If the target of the current goal is  <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code>,
then <code class="docutils literal notranslate"><span class="pre">contrapose!,</span></code> changes the target to  <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>.</p>
<p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">Q</span></code>
and one of the hypotheses is <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code>,
then <code class="docutils literal notranslate"><span class="pre">contrapose!</span> <span class="pre">hp,</span></code> changes the target to  <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">P</span></code>
and changes the hypothesis to <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">Q</span></code>.</p>
<p>Mathematically, this is replacing the target by its contrapositive.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="quantifiers">
<h2>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this heading">&#182;</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">have</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">y</span></code> then
<code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">hpy</span> <span class="pre">:=</span> <span class="pre">hp(y)</span></code> creates a hypothesis <code class="docutils literal notranslate"><span class="pre">hpy</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">y</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rintro</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>, then
<code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">x,</span></code> creates a hypothesis <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> and
changes the target to <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cases</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hp</span> <span class="pre">with</span> <span class="pre">x</span> <span class="pre">key,</span></code> breaks it into
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">x</span></code>.</p>
<p>See also <code class="docutils literal notranslate"><span class="pre">rcases</span></code> to avoid using <code class="docutils literal notranslate"><span class="pre">cases</span></code> repeatedly.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">use</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">X</span></code>, then
<code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">y,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">y</span></code> and tries to close the goal.</p>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">&#10216;_,</span> <span class="pre">_&#10217;,</span></code> and then you get two goals, one with target <code class="docutils literal notranslate"><span class="pre">X</span></code>, and the other is the fact <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">y</span></code>,
where <code class="docutils literal notranslate"><span class="pre">y</span></code> is the witness you entered for <code class="docutils literal notranslate"><span class="pre">X</span></code>.
If you already have the witness <code class="docutils literal notranslate"><span class="pre">y</span></code>, you may type <code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">&#10216;y,</span> <span class="pre">_&#10217;,</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="proving-trivial-statements">
<h2>Proving &#8220;trivial&#8221; statements<a class="headerlink" href="#proving-trivial-statements" title="Permalink to this heading">&#182;</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">refl</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">refl,</span></code> proves things that are literally true by definition.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">norm_num</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">norm_num</span></code> is Lean&#8217;s calculator. If the target has a proof that involves <em>only</em> numbers and arithmetic operations,
then <code class="docutils literal notranslate"><span class="pre">norm_num</span></code> will close this goal.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> is an assumption then <code class="docutils literal notranslate"><span class="pre">norm_num</span> <span class="pre">at</span> <span class="pre">hp,</span></code> tries to use simplify <code class="docutils literal notranslate"><span class="pre">hp</span></code> using basic arithmetic operations.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ring_nf</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ring_nf,</span></code> is Lean&#8217;s symbolic manipulator.
If the target has a proof that involves <em>only</em> algebraic operations,
then <code class="docutils literal notranslate"><span class="pre">ring_nf,</span></code> will close the goal.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">P</span></code> is an assumption then <code class="docutils literal notranslate"><span class="pre">ring_nf</span> <span class="pre">at</span> <span class="pre">hp,</span></code> tries to use simplify <code class="docutils literal notranslate"><span class="pre">hp</span></code> using basic algebraic operations.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">linarith</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">linarith,</span></code> is Lean&#8217;s inequality solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">simp</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">simp,</span></code> is a very complex tactic that tries to use theorems from the mathlib library to close the goal.
You should only ever use <code class="docutils literal notranslate"><span class="pre">simp,</span></code> to <em>close a goal</em> because its behavior changes as more theorems get added to the library.
If you really want to use <code class="docutils literal notranslate"><span class="pre">simp,</span></code> but it doesn&#8217;t close the goal, try <code class="docutils literal notranslate"><span class="pre">squeeze_simp,</span></code>,
and click the instructions given in the goal window.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="equality">
<h2>Equality<a class="headerlink" href="#equality" title="Permalink to this heading">&#182;</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rw</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">f</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code> (or <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8596;</span> <span class="pre">Q</span></code>), then</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">f,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">P</span></code> in the target and replaces it with <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">&#8592;f,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">Q</span></code> in the target and replaces it with <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
</div></blockquote>
<p>If additionally, <code class="docutils literal notranslate"><span class="pre">hr</span> <span class="pre">:</span> <span class="pre">R</span></code> is a hypothesis, then</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">f</span> <span class="pre">at</span> <span class="pre">hr,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">P</span></code> in the expression <code class="docutils literal notranslate"><span class="pre">R</span></code> and replaces it with <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">&#8592;f</span> <span class="pre">at</span> <span class="pre">hr,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">Q</span></code> in the expression <code class="docutils literal notranslate"><span class="pre">R</span></code> and replaces it with <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
</div></blockquote>
<p>Mathematically, this is saying because <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>, we can replace <code class="docutils literal notranslate"><span class="pre">P</span></code> with <code class="docutils literal notranslate"><span class="pre">Q</span></code> (or the other way around).</p>
<p>You can also use this to unfold definitions, for instance if <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code>, then
<code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">surjective,</span></code> will change the goal <code class="docutils literal notranslate"><span class="pre">surjective</span> <span class="pre">f</span></code> to
<code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">(b</span> <span class="pre">:</span> <span class="pre">Y),</span> <span class="pre">&#8707;</span> <span class="pre">(a</span> <span class="pre">:</span> <span class="pre">X),</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>, so you can see what you&#8217;re trying to prove.
For this purpose, you could also use the tactic <code class="docutils literal notranslate"><span class="pre">unfold</span></code>, as in <code class="docutils literal notranslate"><span class="pre">unfold</span> <span class="pre">surjective,</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="induction">
<h2>Induction<a class="headerlink" href="#induction" title="Permalink to this heading">&#182;</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">induction</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code> is a natural number variable, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">Prop</span></code> is a property of natural numbers,
and you want to prove <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> using induction, then <code class="docutils literal notranslate"><span class="pre">induction</span> <span class="pre">n</span> <span class="pre">using</span> <span class="pre">k</span> <span class="pre">ih,</span></code> will create two goals.</p>
<p>One has target <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">0</span></code>, this is the base case.</p>
<p>The other has target <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">(k.succ)</span></code>, where <code class="docutils literal notranslate"><span class="pre">k.succ</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">+</span> <span class="pre">1</span></code>.
(You can rewrite away the <code class="docutils literal notranslate"><span class="pre">.succ</span></code> with <code class="docutils literal notranslate"><span class="pre">nat.succ_eq_add_one</span></code>.)
You&#8217;re also provided an induction hypothesis, <code class="docutils literal notranslate"><span class="pre">ih</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">k</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">refl</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">refl,</span></code> proves things that are literally true by definition.
Often this will handle your base case.</p></td>
</tr>
</tbody>
</table>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Lean at MC 2022</a></h1>








<!-- <h3>Navigation</h3> -->
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="day1.html">1. Logic in Lean - Part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="day2.html">2. Logic in Lean - Part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="day3.html">3. Infinitely Many Primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="day4.html">4. Sqrt 2 is irrational</a></li>
<li class="toctree-l1"><a class="reference internal" href="day5.html">5. Bits &amp; Pieces</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="symbols.html">Pretty Symbols in Lean</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Glossary of Tactics and Lemmas</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://awainverse.github.io/mc2022-Lean/latex/lean_at_mc2022.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/lean-web-editor/">Lean Live Editor</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/mathlib_docs/">Lean Documentation</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/">Leanprover Community</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Aaron Anderson, Apurva Nakade, Jalex Stark.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tactics.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>