
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>2. Logic in Lean - Part 2 &#8212; Lean at MC 2022 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Pretty Symbols in Lean" href="symbols.html" />
    <link rel="prev" title="1. Logic in Lean - Part 1" href="day1.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="logic-in-lean-part-2">
<span id="day2"></span><h1><span class="section-number">2. </span>Logic in Lean - Part 2<a class="headerlink" href="#logic-in-lean-part-2" title="Permalink to this heading">&#182;</a></h1>
<p>The goal today is to wrap up the remaining bits of logic and move on to doing some &#8220;actual math&#8221;.
Remember to <strong>always save your work</strong>.
You might find the <a class="reference internal" href="tactics.html"><span class="doc">Glossary of tactics</span></a> page and the <a class="reference internal" href="symbols.html"><span class="doc">Pretty symbols</span></a> page useful.</p>
<p>Before we move on to new stuff, let&#8217;s understand what we did yesterday.</p>
<section id="behind-the-scenes">
<h2><span class="section-number">2.1. </span>Behind the scenes<a class="headerlink" href="#behind-the-scenes" title="Permalink to this heading">&#182;</a></h2>
<p><strong>A note on brackets:</strong>
It is not uncommon to compose half a dozen functions in Lean.
The brackets get really messy and unwieldy.
As such, Lean will often drop the brackets by following the following conventions.</p>
<ul class="simple">
<li><p>The function <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">R</span> <span class="pre">&#8594;</span> <span class="pre">S</span></code> stands for <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">(Q</span> <span class="pre">&#8594;</span> <span class="pre">(R</span> <span class="pre">&#8594;</span> <span class="pre">S))</span></code>.</p></li>
<li><p>The expression <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">d</span></code> stands for <code class="docutils literal notranslate"><span class="pre">((a</span> <span class="pre">+</span> <span class="pre">b)</span> <span class="pre">+</span> <span class="pre">c)</span> <span class="pre">+</span> <span class="pre">d</span></code>.</p></li>
</ul>
<p>An easy way to remember this is that, arrows are bracketed on the right and binary operators on the left.</p>
<section id="proof-irrelevance">
<h3><span class="section-number">2.1.1. </span>Proof irrelevance<a class="headerlink" href="#proof-irrelevance" title="Permalink to this heading">&#182;</a></h3>
<p>It might feel a bit weird to say that a proposition has proofs as its inhabitants.
Proofs can get huge and it seems unnecessary to have to remember not just the statement but also its proof.
This is something we don&#8217;t normally do in math.
To hide this complication, in type theory there is an axiom, called <em>proof irrelevance</em>, which says that
if <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">:</span> <span class="pre">Prop</span></code> and <code class="docutils literal notranslate"><span class="pre">hp1</span> <span class="pre">hp2</span> <span class="pre">:</span> <span class="pre">P</span></code> then <code class="docutils literal notranslate"><span class="pre">hp1</span> <span class="pre">=</span> <span class="pre">hp2</span></code>.
Taking our <em>analogy</em> with sets further, you can think of a proposition as a set which is either empty or contains a single element (false or true).
In fact, in some forms of type theory (e.g. <a class="reference external" href="https://en.wikipedia.org/wiki/Homotopy_type_theory">homotopy type theory</a>) this is taken as the definition of propositions.
This is of course not true for general types.
For example, <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8800;</span> <span class="pre">1</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code>.</p>
</section>
<section id="proofs-as-functions">
<h3><span class="section-number">2.1.2. </span>Proofs as functions<a class="headerlink" href="#proofs-as-functions" title="Permalink to this heading">&#182;</a></h3>
<p>Every time you successfully construct a proof of a theorem say</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>theorem tautology (P : Prop) : P &#8594; P :=
begin
  rintro hp,
  refine hp,
end
</pre></div>
</div>
<p>Lean constructs a <em>proof term</em> <code class="docutils literal notranslate"><span class="pre">tautology</span> <span class="pre">:</span> <span class="pre">&#8704;</span> <span class="pre">P</span> <span class="pre">:</span> <span class="pre">Prop,</span> <span class="pre">P</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code>
(you can see this by typing <code class="docutils literal notranslate"><span class="pre">#check</span> <span class="pre">tautology</span></code>).</p>
<p>In type theory, the <em>for all</em> quantifier, <code class="docutils literal notranslate"><span class="pre">&#8704;</span></code>, is a generalized function, called a <a class="reference external" href="https://en.wikipedia.org/wiki/Dependent_type">dependent function</a>.
For all practical purposes, we can think of <code class="docutils literal notranslate"><span class="pre">tautology</span></code> as having the type <code class="docutils literal notranslate"><span class="pre">(P</span> <span class="pre">:</span> <span class="pre">Prop)</span> <span class="pre">&#8594;</span> <span class="pre">(P</span> <span class="pre">&#8594;</span> <span class="pre">P)</span></code>.
Note that this is not a function in the classical sense of the word because the codomain <code class="docutils literal notranslate"><span class="pre">(P</span> <span class="pre">&#8594;</span> <span class="pre">P)</span></code> <em>depends</em> on the input variable <code class="docutils literal notranslate"><span class="pre">P</span></code>.
If <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, then <code class="docutils literal notranslate"><span class="pre">tautology(Q)</span></code> is a term of type  <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">&#8594;</span> <span class="pre">Q</span></code>.</p>
<p>Consider a theorem with multiple hypothesis, say</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">theorem</span> <span class="n">hello_world</span> <span class="p">(</span><span class="n">hp</span> <span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="p">(</span><span class="n">hq</span> <span class="p">:</span> <span class="n">Q</span><span class="p">)</span> <span class="p">(</span><span class="n">hr</span> <span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="p">:</span> <span class="n">S</span>
</pre></div>
</div>
<p>Once we provide a proof of it, Lean will create a proof term
<code class="docutils literal notranslate"><span class="pre">hello_world</span> <span class="pre">:</span> <span class="pre">(hp:P)</span> <span class="pre">&#8594;</span> <span class="pre">(hq:Q)</span> <span class="pre">&#8594;</span> <span class="pre">(hr:R)</span> <span class="pre">&#8594;</span> <span class="pre">S</span></code>.
So that if we have terms <code class="docutils literal notranslate"><span class="pre">hp'</span> <span class="pre">:</span> <span class="pre">P</span></code>, <code class="docutils literal notranslate"><span class="pre">hq'</span> <span class="pre">:</span> <span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">hr'</span> <span class="pre">:</span> <span class="pre">R</span></code>
then <code class="docutils literal notranslate"><span class="pre">hello_world</span> <span class="pre">hp'</span> <span class="pre">hq'</span> <span class="pre">hr'</span></code> (note the convenient lack of brackets) will be a term of type <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
<p>Once constructed, any term can be used in a later proof. For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>example (P Q : Prop) : (P &#8594; Q) &#8594; (P &#8594; Q) :=
begin
  refine tautology (P &#8594; Q),
end
</pre></div>
</div>
<p>This is how Lean simulates mathematics.
Every time you prove a theorem using tactics a <em>proof term</em> gets created.
Because of proof irrelevance, Lean forgets the exact content of the proof and
only remembers its type.
All the proof terms can then be used in later proofs.
All of this falls under the giant umbrella of the <a class="reference external" href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry&#8211;Howard correspondence</a>.</p>
</section>
<section id="optional-sidenote-on-lambda">
<h3><span class="section-number">2.1.3. </span>Optional Sidenote on Lambda<a class="headerlink" href="#optional-sidenote-on-lambda" title="Permalink to this heading">&#182;</a></h3>
<p>Speaking of generalized functions, and terms, we can define the term <code class="docutils literal notranslate"><span class="pre">tautology</span></code> directly, without using <code class="docutils literal notranslate"><span class="pre">rintro</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>theorem tautology (P : Prop) : P &#8594; P :=
begin
  refine &#955; hp, hp,
end
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">&#955;</span></code>, typed <code class="docutils literal notranslate"><span class="pre">\lambda</span></code>, plays basically the role of <code class="docutils literal notranslate"><span class="pre">rintro</span></code>.
In general, the term <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">y</span></code> will define a (generalized) function that on input <code class="docutils literal notranslate"><span class="pre">x</span></code>, gives output <code class="docutils literal notranslate"><span class="pre">y</span></code>.
For instance, once we can talk about addition, <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span></code> will be the function that adds 2 to a given natural number.
If you want to, you can play around with using <code class="docutils literal notranslate"><span class="pre">&#955;</span></code> and <code class="docutils literal notranslate"><span class="pre">rintro</span></code> interchangeably.</p>
</section>
</section>
<section id="the-law-of-the-excluded-middle">
<h2><span class="section-number">2.2. </span>The Law of the Excluded Middle<a class="headerlink" href="#the-law-of-the-excluded-middle" title="Permalink to this heading">&#182;</a></h2>
<p>You can prove exactly one of the following using just <code class="docutils literal notranslate"><span class="pre">refine</span></code>, <code class="docutils literal notranslate"><span class="pre">rintro</span></code>, and <code class="docutils literal notranslate"><span class="pre">have</span></code>.
Can you find which one?</p>
<div id="lem-examples-1" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0A%2F--------------------------------------------------------------------------%0A%0AYou%20can%20prove%20exactly%20one%20of%20the%20following%20three%20using%20just%0A%60%60refine%60%60%2C%20%60%60rintro%60%60%2C%20and%20%60%60have%60%60.%0A%0ACan%20you%20find%20which%20one%3F%0A%0A--------------------------------------------------------------------------%2F%0A%0Atheorem%20not_not_self_imp_self%20(P%20%3A%20Prop)%20%3A%20%C2%AC%20%C2%AC%20P%20%E2%86%92%20P%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Atheorem%20contrapositive_converse%20(P%20Q%20%3A%20Prop)%20%3A%20(%C2%ACQ%20%E2%86%92%20%C2%ACP)%20%E2%86%92%20(P%20%E2%86%92%20Q)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Aexample%20(P%20%3A%20Prop)%20%3A%20%C2%AC%20P%20%E2%86%92%20%C2%AC%20%C2%AC%20%C2%AC%20P%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend" id="lem-examples-1" target="_blank" tryitfile="../examples/day2/lem_examples_1.lean">
try it!</a></div><div class="highlight-lean notranslate" id="lem-examples-1"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="sd">/--------------------------------------------------------------------------</span>

<span class="sd">You can prove exactly one of the following three using just</span>
<span class="sd">``refine``, ``rintro``, and ``have``.</span>

<span class="sd">Can you find which one?</span>

<span class="sd">--------------------------------------------------------------------------/</span>

<span class="kd">theorem</span> <span class="n">not_not_self_imp_self</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">P</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">contrapositive_converse</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">Q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">P</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This is because it is not true that <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">&#172;</span> <span class="pre">P</span> <span class="pre">=</span> <span class="pre">P</span></code> <em>by definition</em>, after all,
<code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">&#172;</span> <span class="pre">P</span></code> is <code class="docutils literal notranslate"><span class="pre">(P</span> <span class="pre">&#8594;</span> <span class="pre">false)</span> <span class="pre">&#8594;</span> <span class="pre">false</span></code> which is drastically different from <code class="docutils literal notranslate"><span class="pre">P</span></code>.
There is an extra axiom called <strong>the law of excluded middle</strong> which says that
either <code class="docutils literal notranslate"><span class="pre">P</span></code> is inhabited or <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">P</span></code> is inhabited (and there is no <em>middle</em> option)
and so <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8596;</span> <span class="pre">&#172;</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>.
Lean gives it to us in the form of <code class="docutils literal notranslate"><span class="pre">em</span> <span class="pre">P</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>, although it&#8217;s not always included.
Because some mathematicians would prefer to avoid using this in their proofs,
you have to type the lines <code class="docutils literal notranslate"><span class="pre">noncomputable</span> <span class="pre">theory</span></code> and <code class="docutils literal notranslate"><span class="pre">open_locale</span> <span class="pre">classical</span></code>
near the top of the file, to show that you&#8217;re ok with using all of classical logic!</p>
<div id="lem-examples-2" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0A--%20these%20two%20statements%20tell%20Lean%20to%20use%20the%20law%20of%20excluded%20middle%20as%20necessary%0Anoncomputable%20theory%0Aopen_locale%20classical%0A%0A%0A--BEGIN--%0A%0A%0A%2F--------------------------------------------------------------------------%0A%0A%60%60em%60%60%0A%0A%20%20If%20%60%60P%20%3A%20Prop%60%60%2C%20then%20%60%60em%20P%20%3A%20P%20%E2%88%A8%20%C2%AC%20P%60%60%20lets%20you%20use%20the%20law%20of%20the%20excluded%20middle%20on%20%60%60P%60%60.%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0Atheorem%20not_not_self_imp_self%20(P%20%3A%20Prop)%20%3A%20%C2%AC%20%C2%AC%20P%20%E2%86%92%20P%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Atheorem%20contrapositive_converse%20(P%20Q%20%3A%20Prop)%20%3A%20(%C2%ACQ%20%E2%86%92%20%C2%ACP)%20%E2%86%92%20(P%20%E2%86%92%20Q)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Aexample%20(P%20%3A%20Prop)%20%3A%20%C2%AC%20P%20%E2%86%92%20%C2%AC%20%C2%AC%20%C2%AC%20P%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Atheorem%20principle_of_explosion%20(P%20Q%20%3A%20Prop)%20%3A%20P%20%E2%86%92%20(%C2%AC%20P%20%E2%86%92%20Q)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A--END--" id="lem-examples-2" target="_blank" tryitfile="../examples/day2/lem_examples_2.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/--------------------------------------------------------------------------</span>

<span class="sd">``em``</span>

<span class="sd">  If ``P : Prop``, then ``em P : P &#8744; &#172; P`` lets you use the law of the excluded middle on ``P``.</span>

<span class="sd">Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="sd">--------------------------------------------------------------------------/</span>

<span class="kd">theorem</span> <span class="n">not_not_self_imp_self</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">P</span><span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">contrapositive_converse</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">Q</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">P</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">principle_of_explosion</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>There are more specialized tactics that combine <code class="docutils literal notranslate"><span class="pre">false.elim</span></code> and <code class="docutils literal notranslate"><span class="pre">em</span></code> with other tactics to streamline the process of dealing with negations.
You can read about them at <a class="reference internal" href="tactics.html"><span class="doc">Glossary of tactics</span></a>, and if you want, you can try to shorten some of your above proofs with them.</p>
</section>
<section id="quantifiers">
<h2><span class="section-number">2.3. </span>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this heading">&#182;</a></h2>
<p>As mentioned it the introduction, the <em>for all</em> quantifier, <code class="docutils literal notranslate"><span class="pre">&#8704;</span></code>, is a generalization of a function.
As such the tactics for dealing with <code class="docutils literal notranslate"><span class="pre">&#8704;</span></code> are the same as those for <code class="docutils literal notranslate"><span class="pre">&#8594;</span></code>.
(Type it as <code class="docutils literal notranslate"><span class="pre">\forall</span></code>.)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">have</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">X</span></code> then
<code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">hpy</span> <span class="pre">:=</span> <span class="pre">hp(y)</span></code> creates a hypothesis <code class="docutils literal notranslate"><span class="pre">hpy</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">y</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rintro</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>, then
<code class="docutils literal notranslate"><span class="pre">rintro</span> <span class="pre">x,</span></code> creates a hypothesis <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> and
changes the target to <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">x</span></code>.</p></td>
</tr>
</tbody>
</table>
<p>The <em>there exists</em> quantifier, <code class="docutils literal notranslate"><span class="pre">&#8707;</span></code>, in type theory, uses similar tools to
If you want to prove a statement <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code> then you need to provide a witness.
If you have a term <code class="docutils literal notranslate"><span class="pre">hp</span> <span class="pre">:</span> <span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code> then from this you can extract a witness.
(Type it as <code class="docutils literal notranslate"><span class="pre">\exists</span></code>.)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cases</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">hp</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>, then
<code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">hp</span> <span class="pre">with</span> <span class="pre">x</span> <span class="pre">key,</span></code> breaks it into
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">use</span></code></p></td>
<td><p>If the target of the current goal is <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X,</span> <span class="pre">P</span> <span class="pre">x</span></code>
and <code class="docutils literal notranslate"><span class="pre">y</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">X</span></code>, then
<code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">y,</span></code> changes the target to <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">y</span></code> and tries to close the goal.</p></td>
</tr>
</tbody>
</table>
<p>Finally, we know enough Lean to start doing some fun stuff.</p>
<section id="barber-paradox">
<h3><span class="section-number">2.3.1. </span>Barber paradox<a class="headerlink" href="#barber-paradox" title="Permalink to this heading">&#182;</a></h3>
<p>Let&#8217;s disprove the &#8220;barber paradox&#8221; due to Bertrand Russell.
The claim is that in a certain town there is a (male) barber that shaves all the men who do not shave themselves. (Why is this a paradox?)
Prove that this is a contradiction.
Here are some <a class="reference internal" href="hint_1_barber_paradox.html"><span class="doc">hints</span></a> if you get stuck.</p>
<div id="id1" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A--%20the%20next%20two%20lines%20let%20us%20use%20the%20law%20of%20the%20excluded%20middle%20without%20trouble%0Anoncomputable%20theory%0Aopen_locale%20classical%0A%0A--BEGIN--%0A%0A%2F--------------------------------------------------------------------------%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0A--%20men%20is%20type.%0A--%20x%20%3A%20men%20means%20x%20is%20a%20man%20in%20the%20town%0A--%20shaves%20x%20y%20is%20inhabited%20if%20x%20shaves%20y%0A%0Avariables%20(men%20%3A%20Type)%20(barber%20%3A%20men)%0Avariable%20%20(shaves%20%3A%20men%20%E2%86%92%20men%20%E2%86%92%20Prop)%0A%0Aexample%20%3A%20%C2%AC%20(%E2%88%80%20x%20%3A%20men%2C%20shaves%20barber%20x%20%E2%86%94%20%C2%AC%20shaves%20x%20x)%20%3A%3D%0A%20%20begin%0A%20%20%20%20sorry%2C%0A%20%20end%0A--END--" id="id1" target="_blank" tryitfile="../examples/day2/barber_paradox.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/--------------------------------------------------------------------------</span>

<span class="sd">Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="sd">--------------------------------------------------------------------------/</span>

<span class="c1">-- men is type.</span>
<span class="c1">-- x : men means x is a man in the town</span>
<span class="c1">-- shaves x y is inhabited if x shaves y</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">men</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">barber</span> <span class="o">:</span> <span class="n">men</span><span class="o">)</span>
<span class="kd">variable</span>  <span class="o">(</span><span class="n">shaves</span> <span class="o">:</span> <span class="n">men</span> <span class="bp">&#8594;</span> <span class="n">men</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">men</span><span class="o">,</span> <span class="n">shaves</span> <span class="n">barber</span> <span class="n">x</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span> <span class="n">shaves</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">begin</span>
    <span class="gr">sorry</span><span class="o">,</span>
  <span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="mathcampers-singing-paradox">
<h3><span class="section-number">2.3.2. </span>Mathcampers singing paradox<a class="headerlink" href="#mathcampers-singing-paradox" title="Permalink to this heading">&#182;</a></h3>
<p>Assume that the main lounge is non-empty.
At a fixed moment in time, there is someone in the lounge such that,
if they are singing,
then everyone in the lounge is singing.
(See <a class="reference internal" href="hint_1_mcsp.html"><span class="doc">hints</span></a>).</p>
<div id="lounge-paradox" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A--%20the%20next%20two%20lines%20let%20us%20use%20the%20law%20of%20the%20excluded%20middle%20without%20trouble%0Anoncomputable%20theory%0Aopen_locale%20classical%0A%0A--BEGIN--%0A%0A%2F--------------------------------------------------------------------------%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0A--%20camper%20is%20a%20type.%0A--%20If%20x%20%3A%20camper%20then%20x%20is%20a%20camper%20in%20the%20main%20lounge.%0A--%20singing(x)%20is%20inhabited%20if%20x%20is%20singing%0A%0Atheorem%20math_campers_singing_paradox%0A%20%20(camper%20%3A%20Type)%0A%20%20(singing%20%3A%20camper%20%E2%86%92%20Prop)%0A%20%20(alice%20%3A%20camper)%20--%20making%20sure%20that%20there%20is%20at%20least%20one%20camper%20in%20the%20lounge%0A%20%20%3A%20%E2%88%83%20x%20%3A%20camper%2C%20(singing%20x%20%E2%86%92%20(%E2%88%80%20y%20%3A%20camper%2C%20singing%20y))%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A--END--" id="lounge-paradox" target="_blank" tryitfile="../examples/day2/lounge_paradox.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="sd">/--------------------------------------------------------------------------</span>

<span class="sd">Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="sd">--------------------------------------------------------------------------/</span>

<span class="c1">-- camper is a type.</span>
<span class="c1">-- If x : camper then x is a camper in the main lounge.</span>
<span class="c1">-- singing(x) is inhabited if x is singing</span>

<span class="kd">theorem</span> <span class="n">math_campers_singing_paradox</span>
  <span class="o">(</span><span class="n">camper</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
  <span class="o">(</span><span class="n">singing</span> <span class="o">:</span> <span class="n">camper</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">alice</span> <span class="o">:</span> <span class="n">camper</span><span class="o">)</span> <span class="c1">-- making sure that there is at least one camper in the lounge</span>
  <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">camper</span><span class="o">,</span> <span class="o">(</span><span class="n">singing</span> <span class="n">x</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="n">y</span> <span class="o">:</span> <span class="n">camper</span><span class="o">,</span> <span class="n">singing</span> <span class="n">y</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="relationship-conundrum">
<h3><span class="section-number">2.3.3. </span>Relationship conundrum<a class="headerlink" href="#relationship-conundrum" title="Permalink to this heading">&#182;</a></h3>
<p>A relation <code class="docutils literal notranslate"><span class="pre">r</span></code> on a type <code class="docutils literal notranslate"><span class="pre">X</span></code> is a map <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Prop</span></code>.
We say that <code class="docutils literal notranslate"><span class="pre">x</span></code> is <em>related</em> to <code class="docutils literal notranslate"><span class="pre">y</span></code> if <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">x</span> <span class="pre">y</span></code> is inhabited.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is reflexive if <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to itself.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is symmetric if <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">:</span> <span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to <code class="docutils literal notranslate"><span class="pre">y</span></code> implies <code class="docutils literal notranslate"><span class="pre">y</span></code> is related to <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is transitive if <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">:</span> <span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> is related to <code class="docutils literal notranslate"><span class="pre">x</span></code> implies <code class="docutils literal notranslate"><span class="pre">z</span></code> is related to <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r</span></code> is connected if for all <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code> there is a <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">:</span> <span class="pre">Y</span></code> such that <code class="docutils literal notranslate"><span class="pre">x</span></code> is related to <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
</ul>
<p>Show that if a relation is symmetric, transitive, and connected,
then it is also reflexive.</p>
<div id="relationship-paradox" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Avariable%20X%20%3A%20Type%0A%0Atheorem%20reflexive_of_symmetric_transitive_and_connected%0A%20%20(r%20%3A%20X%20%E2%86%92%20X%20%E2%86%92%20Prop)%0A%20%20(h_symm%20%3A%20%E2%88%80%20x%20y%20%3A%20X%2C%20r%20x%20y%20%E2%86%92%20r%20y%20x)%0A%20%20(h_trans%20%3A%20%E2%88%80%20x%20y%20z%20%3A%20X%2C%20r%20x%20y%20%E2%86%92%20r%20y%20z%20%E2%86%92%20r%20x%20z)%0A%20%20(h_connected%20%3A%20%E2%88%80%20x%2C%20%E2%88%83%20y%2C%20r%20x%20y)%0A%3A%20(%E2%88%80%20x%20%3A%20X%2C%20r%20x%20x)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend" id="relationship-paradox" target="_blank" tryitfile="../examples/day2/relationship_paradox.lean">
try it!</a></div><div class="highlight-lean notranslate" id="relationship-paradox"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variable</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>

<span class="kd">theorem</span> <span class="n">reflexive_of_symmetric_transitive_and_connected</span>
  <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_symm</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_trans</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="n">y</span> <span class="n">z</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span>
  <span class="o">(</span><span class="n">h_connected</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">y</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span>
<span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="n">r</span> <span class="n">x</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
</section>
<section id="equality">
<h2><span class="section-number">2.4. </span>Equality<a class="headerlink" href="#equality" title="Permalink to this heading">&#182;</a></h2>
<p>So far we have not seen how to deal with propositions of the form <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>, for example, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">n(n</span> <span class="pre">+</span> <span class="pre">1)/2</span></code>. Proving these propositions by hand requires messing around with the axioms of type theory.
<em>Using</em> equalities on the other hand is very easy. The rewrite tactic (usually shortened to <code class="docutils literal notranslate"><span class="pre">rw</span></code>) let&#8217;s you replace the left hand side of an equality with the right hand side.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rw</span></code></p></td>
<td><p>If <code class="docutils literal notranslate"><span class="pre">f</span></code> is a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code> (or <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&#8596;</span> <span class="pre">Q</span></code>), then</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">f,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">P</span></code> in the target and replaces it with <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">&#8592;f,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">Q</span></code> in the target and replaces it with <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
</div></blockquote>
<p>Additionally, if <code class="docutils literal notranslate"><span class="pre">hr</span> <span class="pre">:</span> <span class="pre">R</span></code> is a hypothesis, then</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">f</span> <span class="pre">at</span> <span class="pre">hr,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">P</span></code> in the expression <code class="docutils literal notranslate"><span class="pre">R</span></code> and replaces it with <code class="docutils literal notranslate"><span class="pre">Q</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">&#8592;f</span> <span class="pre">at</span> <span class="pre">hr,</span></code> searches for <code class="docutils literal notranslate"><span class="pre">Q</span></code> in the expression <code class="docutils literal notranslate"><span class="pre">R</span></code> and replaces it with <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p>
</div></blockquote>
<p>Mathematically, this is saying &#8220;because <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>, we can replace <code class="docutils literal notranslate"><span class="pre">P</span></code> with <code class="docutils literal notranslate"><span class="pre">Q</span></code> (or the other way around)&#8221;.</p>
</td>
</tr>
</tbody>
</table>
<p>To get the left arrow, type <code class="docutils literal notranslate"><span class="pre">\l</span></code>. If you want to rewrite a bunch of things in a row, you can type <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">[h1,</span> <span class="pre">h2,</span> <span class="pre">h3],</span></code>.</p>
<div id="rw-examples" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%20data.nat.basic%0Aopen%20nat%0A%0A%2F--------------------------------------------------------------------------%0A%0A%20%20%60%60rw%60%60%0A%0A%20%20%20%20If%20%60%60f%60%60%20is%20a%20term%20of%20type%20%60%60P%20%3D%20Q%60%60%20(or%20%60%60P%20%E2%86%94%20Q%60%60)%2C%20then%0A%20%20%20%20%60%60rw%20f%60%60%20replaces%20%60%60P%60%60%20with%20%60%60Q%60%60%20in%20the%20target.%0A%20%20%20%20Other%20variants%3A%0A%20%20%20%20%20%20%60%60rw%20f%20at%20hp%60%60%2C%20%60%60rw%20%E2%86%90f%60%60%2C%20%60%60rw%20%E2%86%90f%20at%20hr%60%60.%0A%0A%20%20Delete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A%20%20--------------------------------------------------------------------------%2F%0A%0Atheorem%20add_self_self_eq_double%0A%20%20(x%20%3A%20%E2%84%95)%0A%3A%20x%20%2B%20x%20%3D%202%20*%20x%20%3A%3D%0Abegin%0A%20%20rw%20two_mul%2C%0Aend%0A%0A%2F-%0AFor%20the%20following%20problem%2C%20use%0A%20%20mul_comm%20a%20b%20%3A%20a%20*%20b%20%3D%20b%20*%20a%0A-%2F%0A%0Aexample%20(a%20b%20c%20d%20%3A%20%E2%84%95)%0A%20%20(hyp%20%3A%20c%20%3D%20d%20*%20a%20%2B%20b)%0A%20%20(hyp'%20%3A%20b%20%3D%20a%20*%20d)%0A%3A%20c%20%3D%202%20*%20(a%20*%20d)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0A%2F-%0AFor%20the%20following%20problem%2C%20use%0A%20%20nat.sub_self%20(x%20%3A%20%E2%84%95)%20%3A%20x%20-%20x%20%3D%200%0A-%2F%0A%0Aexample%20(a%20b%20c%20d%20%3A%20%E2%84%95)%0A%20%20(hyp%20%3A%20c%20%3D%20b%20*%20a%20-%20d)%0A%20%20(hyp'%20%3A%20d%20%3D%20a%20*%20b)%0A%3A%20c%20%3D%200%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend" id="rw-examples" target="_blank" tryitfile="../examples/day2/rw_examples.lean">
try it!</a></div><div class="highlight-lean notranslate" id="rw-examples"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span> <span class="n">data.nat.basic</span>
<span class="kn">open</span> <span class="n">nat</span>

<span class="sd">/--------------------------------------------------------------------------</span>

<span class="sd">  ``rw``</span>

<span class="sd">    If ``f`` is a term of type ``P = Q`` (or ``P &#8596; Q``), then</span>
<span class="sd">    ``rw f`` replaces ``P`` with ``Q`` in the target.</span>
<span class="sd">    Other variants:</span>
<span class="sd">      ``rw f at hp``, ``rw &#8592;f``, ``rw &#8592;f at hr``.</span>

<span class="sd">  Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="sd">  --------------------------------------------------------------------------/</span>

<span class="kd">theorem</span> <span class="n">add_self_self_eq_double</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span>
<span class="o">:</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">two_mul</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">For the following problem, use</span>
<span class="cm">  mul_comm a b : a * b = b * a</span>
<span class="cm">-/</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">d</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hyp&#39;</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span>
<span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">d</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">For the following problem, use</span>
<span class="cm">  nat.sub_self (x : &#8469;) : x - x = 0</span>
<span class="cm">-/</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">-</span> <span class="n">d</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hyp&#39;</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span>
<span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><section id="surjective-functions">
<h3><span class="section-number">2.4.1. </span>Surjective functions<a class="headerlink" href="#surjective-functions" title="Permalink to this heading">&#182;</a></h3>
<p>Recall that a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code> is surjective if for every <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">:</span> <span class="pre">Y</span></code> there exists a term <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">X</span></code>
such that <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">y</span></code>.
In type theory, for every function <code class="docutils literal notranslate"><span class="pre">f</span></code> we can define a corresponding proposition
<code class="docutils literal notranslate"><span class="pre">surjective</span> <span class="pre">(f)</span> <span class="pre">:=</span> <span class="pre">&#8704;</span> <span class="pre">y,</span> <span class="pre">&#8707;</span> <span class="pre">x,</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> and a function being surjective is equivalent to saying that the proposition <code class="docutils literal notranslate"><span class="pre">surjective(f)</span></code> is inhabited.</p>
<div id="surjective" style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0Aopen%20function%0A%0A%2F--------------------------------------------------------------------------%0A%0A%60%60rw%60%60%0A%0A%20%20If%20it%20gets%20hard%20to%20keep%20track%20of%20the%20definition%20of%20%60%60surjective%60%60%2C%0A%20%20you%20can%20use%20%60%60rw%20surjective%2C%60%60%20or%20%60%60rw%20surjective%20at%20h%2C%60%60%0A%20%20to%20get%20rid%20of%20it.%20(This%20rewrites%20using%20the%20definition%20of%20surjective).%0A%20%20Typing%20%60%60rw%20surjective%20at%20*%2C%60%60%20will%20unfold%20it%0A%20%20everywhere%20at%20once.%0A%0ADelete%20the%20%60%60sorry%2C%60%60%20below%20and%20replace%20them%20with%20a%20legitimate%20proof.%0A%0A--------------------------------------------------------------------------%2F%0A%0Avariables%20X%20Y%20Z%20%3A%20Type%0Avariables%20(f%20%3A%20X%20%E2%86%92%20Y)%20(g%20%3A%20Y%20%E2%86%92%20Z)%0A%0A%2F-%0Asurjective%20(f%20%3A%20X%20%E2%86%92%20Y)%20%3A%3D%20%E2%88%80%20y%2C%20%E2%88%83%20x%2C%20f%20x%20%3D%20y%0A%0AYou%20may%20also%20want%20to%20try%20%60%60function.comp_app%60%60%0A-%2F%0A%0Aexample%0A%20%20(hf%20%3A%20surjective%20f)%0A%20%20(hg%20%3A%20surjective%20g)%0A%20%20%3A%20surjective%20(g%20%E2%88%98%20f)%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend%0A%0Aexample%0A%20%20(hgf%20%3A%20surjective%20(g%20%E2%88%98%20f))%0A%20%20%3A%20surjective%20g%20%3A%3D%0Abegin%0A%20%20sorry%2C%0Aend" id="surjective" target="_blank" tryitfile="../examples/day2/surjective.lean">
try it!</a></div><div class="highlight-lean notranslate" id="surjective"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">open</span> <span class="n">function</span>

<span class="sd">/--------------------------------------------------------------------------</span>

<span class="sd">``rw``</span>

<span class="sd">  If it gets hard to keep track of the definition of ``surjective``,</span>
<span class="sd">  you can use ``rw surjective,`` or ``rw surjective at h,``</span>
<span class="sd">  to get rid of it. (This rewrites using the definition of surjective).</span>
<span class="sd">  Typing ``rw surjective at *,`` will unfold it</span>
<span class="sd">  everywhere at once.</span>

<span class="sd">Delete the ``sorry,`` below and replace them with a legitimate proof.</span>

<span class="sd">--------------------------------------------------------------------------/</span>

<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"></span>
<span class="cm">surjective (f : X &#8594; Y) := &#8704; y, &#8707; x, f x = y</span>

<span class="cm">You may also want to try ``function.comp_app``</span>
<span class="cm">-/</span>

<span class="kd">example</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span>
  <span class="o">(</span><span class="n">hgf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">))</span>
  <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Lean at MC 2022</a></h1>








<!-- <h3>Navigation</h3> -->
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="day1.html">1. Logic in Lean - Part 1</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Logic in Lean - Part 2</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#behind-the-scenes">2.1. Behind the scenes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-law-of-the-excluded-middle">2.2. The Law of the Excluded Middle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quantifiers">2.3. Quantifiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#equality">2.4. Equality</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="symbols.html">Pretty Symbols in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Glossary of Tactics and Lemmas</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://awainverse.github.io/mc2022-Lean/latex/lean_at_mc2022.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/lean-web-editor/">Lean Live Editor</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/mathlib_docs/">Lean Documentation</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover-community.github.io/">Leanprover Community</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Aaron Anderson, Apurva Nakade, Jalex Stark.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/day2.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>